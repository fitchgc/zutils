{"version":3,"sources":["../../src/utils/bn.util.ts"],"sourcesContent":["export declare type HexString = string\nexport declare type Numbers = number | bigint | string | HexString\n\nconst isHexStrict = hex => typeof hex === 'string' && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex)\nexport declare type ValidInputTypes = Uint8Array | bigint | string | number | boolean\nexport const isHex = (hex: ValidInputTypes): boolean =>\n  typeof hex === 'number' ||\n  typeof hex === 'bigint' ||\n  (typeof hex === 'string' && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex))\nconst base = BigInt(10)\nconst expo10 = (expo: number) => base ** BigInt(expo)\n\nexport const ethUnitMap = {\n  noether: BigInt('0'),\n  wei: BigInt(1),\n  kwei: expo10(3),\n  Kwei: expo10(3),\n  babbage: expo10(3),\n  femtoether: expo10(3),\n  mwei: expo10(6),\n  Mwei: expo10(6),\n  lovelace: expo10(6),\n  picoether: expo10(6),\n  gwei: expo10(9),\n  Gwei: expo10(9),\n  shannon: expo10(9),\n  nanoether: expo10(9),\n  nano: expo10(9),\n  szabo: expo10(12),\n  microether: expo10(12),\n  micro: expo10(12),\n  finney: expo10(15),\n  milliether: expo10(15),\n  milli: expo10(15),\n  ether: expo10(18),\n  kether: expo10(21),\n  grand: expo10(21),\n  mether: expo10(24),\n  gether: expo10(27),\n  tether: expo10(30),\n}\n\nexport type EtherUnits = keyof typeof ethUnitMap\n\n/**\n * Converts value to it's number representation\n */\nexport const hexToNumber = (value: string): bigint | number => {\n  if (!isHexStrict(value)) {\n    throw new Error('Invalid hex string')\n  }\n\n  const [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value]\n  const num = BigInt(hexValue)\n\n  if (num > Number.MAX_SAFE_INTEGER) {\n    return negative ? -num : num\n  }\n\n  if (num < Number.MIN_SAFE_INTEGER) {\n    return num\n  }\n\n  return negative ? -1 * Number(num) : Number(num)\n}\n\nexport const toNumber = (value: Numbers): number | bigint => {\n  if (typeof value === 'number') {\n    return value\n  }\n\n  if (typeof value === 'bigint') {\n    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value\n  }\n\n  if (typeof value === 'string' && isHexStrict(value)) {\n    return hexToNumber(value)\n  }\n\n  try {\n    return toNumber(BigInt(value))\n  } catch {\n    throw new Error('ivalid number: ' + value)\n  }\n}\n\n/**\n * Auto converts any given value into it's bigint representation\n *\n * @param value - The value to convert\n * @returns - Returns the value in bigint representation\n\n * @example\n * ```ts\n * console.log(web3.utils.toBigInt(1));\n * > 1n\n * ```\n */\nexport const toBigInt = (value: unknown): bigint => {\n  if (typeof value === 'number') {\n    return BigInt(value)\n  }\n\n  if (typeof value === 'bigint') {\n    return value\n  }\n\n  // isHex passes for dec, too\n  if (typeof value === 'string' && isHex(value)) {\n    return BigInt(value)\n  }\n\n  if (typeof value === 'string' && value.indexOf(',') >= 0) {\n    return BigInt(value.replace(/,/g, ''))\n  }\n\n  throw new Error('invalid number' + value)\n}\n\nexport const toBigWei = (number: Numbers, unit: EtherUnits = 'ether'): bigint => {\n  return toBigInt(toWei(number, unit))\n}\n\nexport const toWei = (number: Numbers, unit: EtherUnits = 'ether'): string => {\n  const denomination = ethUnitMap[unit]\n\n  if (!denomination) {\n    throw new Error('error unit: ' + unit)\n  }\n\n  // if value is decimal e.g. 24.56 extract `integer` and `fraction` part\n  // to avoid `fraction` to be null use `concat` with empty string\n  typeof number === 'string' && number.indexOf(',') >= 0 && (number = number.replace(/,/g, ''))\n  const [integer, fraction] = String(typeof number === 'string' && !isHexStrict(number) ? number : toNumber(number))\n    .split('.')\n    .concat('')\n\n  // join the value removing `.` from\n  // 24.56 -> 2456\n  const value = BigInt(`${integer}${fraction}`)\n\n  // multiply value with denomination\n  // 2456 * 1000000 -> 2456000000\n  const updatedValue = value * denomination\n\n  // count number of zeros in denomination\n  const numberOfZerosInDenomination = denomination.toString().length - 1\n\n  // check which either `fraction` or `denomination` have lower number of zeros\n  const decimals = Math.min(fraction.length, numberOfZerosInDenomination)\n\n  if (decimals === 0) {\n    return updatedValue.toString()\n  }\n\n  // Add zeros to make length equal to required decimal points\n  // If string is larger than decimal points required then remove last zeros\n  return updatedValue.toString().padStart(decimals, '0').slice(0, -decimals)\n}\n\n/**\n * Takes a number of wei and converts it to any other ether unit.\n * @param number - The value in wei\n * @param unit - The unit to convert to\n * @returns - Returns the converted value in the given unit\n *\n * @example\n * ```ts\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\n * > 0.000000000000000001\n *\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\n * > 0.000000001\n * ```\n */\nexport const fromWei = (number: Numbers, unit: EtherUnits = 'ether'): string => {\n  const denomination = ethUnitMap[unit]\n\n  if (!denomination) {\n    throw new Error('invalid unit: ' + unit)\n  }\n\n  // value in wei would always be integer\n  // 13456789, 1234\n  const value = String(toNumber(number))\n\n  // count number of zeros in denomination\n  // 1000000 -> 6\n  const numberOfZerosInDenomination = denomination.toString().length - 1\n\n  if (numberOfZerosInDenomination <= 0) {\n    return value.toString()\n  }\n\n  // pad the value with required zeros\n  // 13456789 -> 13456789, 1234 -> 001234\n  const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0')\n\n  // get the integer part of value by counting number of zeros from start\n  // 13456789 -> '13'\n  // 001234 -> ''\n  const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination)\n\n  // get the fraction part of value by counting number of zeros backward\n  // 13456789 -> '456789'\n  // 001234 -> '001234'\n  const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '')\n\n  if (integer === '') {\n    return `0.${fraction}`\n  }\n\n  if (fraction === '') {\n    return integer\n  }\n\n  return `${integer}.${fraction}`\n}\n"],"mappings":"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","names":[]}