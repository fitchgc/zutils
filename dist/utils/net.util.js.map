{"version":3,"sources":["../../src/common/ZError.ts","../../src/utils/net.util.ts"],"sourcesContent":["export class ZError implements Error {\n  code: string\n  statusCode?: number\n  message: string\n  name: string\n\n  constructor(statusCode: number, message: string) {\n    this.statusCode = statusCode\n    this.message = message\n  }\n}\n","import { ZError } from 'common/ZError'\nimport fetch, { Response, RequestInit } from 'node-fetch'\n\nconst TIMEOUT_ERROR = new Error('timeout')\n\n/**\n * Execute fetch and verify that the response was successful.\n *\n * @param request - Request information.\n * @param options - Fetch options.\n * @returns The fetch response.\n */\nexport async function successfulFetch(request: string, options?: RequestInit): Promise<any> {\n  const response = await fetch(request, options)\n  if (!response.ok) {\n    throw new Error(`Fetch failed with status '${response.status}' for request '${request}'`)\n  }\n  return response\n}\n\n/**\n * Execute fetch and return object response.\n *\n * @param request - The request information.\n * @param options - The fetch options.\n * @returns The fetch response JSON data.\n */\nexport async function handleFetch(request: string, options?: RequestInit) {\n  const response = await successfulFetch(request, options)\n  const object = await response.json()\n  return object\n}\n\n/**\n * Execute fetch and return object response, log if known error thrown, otherwise rethrow error.\n *\n * @param request - the request options object\n * @param request.url - The request url to query.\n * @param request.options - The fetch options.\n * @param request.timeout - Timeout to fail request\n * @param request.errorCodesToCatch - array of error codes for errors we want to catch in a particular context\n * @returns The fetch response JSON data or undefined (if error occurs).\n */\nexport async function fetchWithErrorHandling({\n  url,\n  options,\n  timeout,\n  errorCodesToCatch,\n}: {\n  url: string\n  options?: RequestInit\n  timeout?: number\n  errorCodesToCatch?: number[]\n}) {\n  let result\n  try {\n    if (timeout) {\n      result = Promise.race([\n        await handleFetch(url, options),\n        new Promise<Response>((_, reject) =>\n          setTimeout(() => {\n            reject(TIMEOUT_ERROR)\n          }, timeout),\n        ),\n      ])\n    } else {\n      result = await handleFetch(url, options)\n    }\n  } catch (e) {\n    logOrRethrowError(e, errorCodesToCatch)\n  }\n  return result\n}\n\n/**\n * Fetch that fails after timeout.\n *\n * @param url - Url to fetch.\n * @param options - Options to send with the request.\n * @param timeout - Timeout to fail request.\n * @returns Promise resolving the request.\n */\nexport async function timeoutFetch(url: string, options?: RequestInit, timeout = 500): Promise<Response> {\n  return Promise.race([\n    successfulFetch(url, options),\n    new Promise<Response>((_, reject) =>\n      setTimeout(() => {\n        reject(TIMEOUT_ERROR)\n      }, timeout),\n    ),\n  ])\n}\n\n/**\n * Utility method to log if error is a common fetch error and otherwise rethrow it.\n *\n * @param error - Caught error that we should either rethrow or log to console\n * @param codesToCatch - array of error codes for errors we want to catch and log in a particular context\n */\nfunction logOrRethrowError(error: any, codesToCatch: number[] = []) {\n  if (!error) {\n    return\n  }\n\n  const includesErrorCodeToCatch = codesToCatch.some(code =>\n    error.message.includes(`Fetch failed with status '${code}'`),\n  )\n\n  if (\n    error instanceof Error &&\n    (includesErrorCodeToCatch || error.message.includes('Failed to fetch') || error === TIMEOUT_ERROR)\n  ) {\n    console.error(error)\n  } else {\n    throw error\n  }\n}\n\nexport function generateHeader() {\n  let random = function (start, end) {\n    return (Math.random() * (end - start) + start) | 0\n  }\n  let getIp = function () {\n    return `${random(1, 254)}.${random(1, 254)}.${random(1, 254)}.${random(1, 254)}`\n  }\n  let time = Date.now()\n  let useragent = `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${\n    (70 + Math.random() * 10) | 0\n  }.0.4324.${(Math.random() * 100) | 0} Safari/537.36`\n  const ip = getIp()\n  return {\n    'Refresh-Token': (time -= 5000),\n    'Cache-Control': 'no-cache',\n    'User-Agent': useragent,\n    'X-Forwarded-For': ip,\n    'X-Real-IP': ip,\n    'Content-Type': 'application/json',\n  }\n}\n\nexport const checkParamsNeeded = (...args) => {\n  args.forEach(arg => {\n    if (!arg) {\n      throw new ZError(10, 'params mismatch')\n    }\n  })\n}\n\n/**\n * 生成 key1=val1&key2=val2的字符串\n * @param {object} data 需要处理的对象\n * @param {boolean} sort 是否按key生序重排\n * @param {boolean} ignoreNull 是否过滤空值(空格或者null值不参与拼接)\n * @param splitChar 连接的字符, 默认是&\n * @param equalChar =\n */\nexport function generateKVStr({\n  data = {},\n  sort = false,\n  encode = false,\n  ignoreNull = true,\n  splitChar = '&',\n  equalChar = '=',\n  uri = '',\n}: {\n  data?: any\n  sort?: boolean\n  encode?: boolean\n  ignoreNull?: boolean\n  splitChar?: string\n  equalChar?: string\n  uri?: string\n}) {\n  const keys = Object.keys(data)\n  sort && keys.sort()\n  let result = ''\n  let i = 0\n  for (let key of keys) {\n    if (ignoreNull && !data[key]) {\n      continue\n    }\n    if (i++ > 0) result += splitChar\n    if (encode) {\n      result += `${key}${equalChar}${encodeURIComponent(data[key])}`\n    } else {\n      result += `${key}${equalChar}${data[key]}`\n    }\n  }\n  if (uri) {\n    const joinChar = uri.search(/\\?/) === -1 ? '?' : '&'\n    result = uri + joinChar + result\n  }\n  return result\n}\n\n/**\n * 将key1=val&key2=val的字符串组装成对象\n * @param str key1=val&key2=val的字符串\n * @param splitChar 连接的字符, 默认是&\n * @param equalChar =\n */\nexport function keyValToObject(str: string, splitChar: string = '&', equalChar = '='): {} {\n  let result: any = {}\n  if (!str) {\n    return result\n  }\n  let arrs = str.split(splitChar)\n  for (let sub of arrs) {\n    let subArr = sub.split(equalChar)\n    result[subArr[0]] = subArr[1]\n  }\n  return result\n}\n\nexport const RE_URL_SCHEME = /^(.+?):\\/\\/.+?$/\n/**\n * 获取url中的scheme\n * @param url\n * @returns\n */\nexport function findUrlScheme(url: string) {\n  let result = url.match(RE_URL_SCHEME)\n  if (!result) {\n    return ''\n  }\n  return result[1]\n}\n\n/**\n * 解析jwt token中的用户信息, 不校验签名\n * @param token\n * @returns\n */\nexport function decodeJWT(token: string) {\n  let strings = token.split('.')\n  var userinfo = JSON.parse(\n    decodeURIComponent(encodeURIComponent(window.atob(strings[1].replace(/-/g, '+').replace(/_/g, '/')))),\n  )\n  return userinfo\n}\n"],"mappings":"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","names":[]}